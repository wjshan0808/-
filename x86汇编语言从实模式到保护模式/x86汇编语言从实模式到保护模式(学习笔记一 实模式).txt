                    x86汇编语言从实模式到保护模式
                            (学习笔记一 实模式)

第一章 十六进制计数法
  0.在计算机里二进制数字对应着高(1)低(0)电平的组合
  1.一种计数法的数符个数称为基数
  2.每个数符位都有一个权值(从右向左, 以基数为底, 指数从0递增的幂)
  3.N进制数转十进制数, 依次将每一个数位值乘以其权值相加
  4.十进制数转N进制数, 反复除以N直到商为0, 将余数从近至远, 由左向右拼接, 即得N进制数
  
第二章 处理器、内存和指令
  0.高字节位于高地址, 低字节位于低地址, 称为低端字节序(Little Endian)
  1.一个处理器能够识别的指令的集合, 称为该处理器的指令集
  2.将一个16位的寄存器当成两个8位的寄存器来用时, 对其中一个8位寄存器的操作不会影响到另一个8位寄存器
  3.在指令中使用绝对内存地址的程序是无法重定位的
  4.处理器访问内存时把指令中指定的内存地址看成是段内的偏移地址, 而不是物理地址
  5.算术逻辑部件(ALU)在进行数据传送或者算术逻辑运算的时候, 需要通过一个叫数据暂存器的寄存器中转
  6.控制器使处理器自动运行, 其内部的6字节指令预取队列, 加快指令执行速度
  7.默认使用DS寄存器作为数据段地址
  8.只有处理器才能直接根据当前指令的长度来改变IP寄存器的值, 使其指向下一条指令 
  9.8086处理器提供了20根地址线, 可访问达1MB范围内存的物理地址(65536个16字节的段)
  10.8086处理器先将段寄存器值左移4位(乘以0x10), 再同偏移地址值相加, 形成20位的物理地址
  11.8086处理器的逻辑分段起始地址(偏移地址从0x00开始)都是16的倍数, 称为按16字节对齐
  12.8086内存中的一个物理地址只要位于访问段的64KB范围内, 即可对应该段的逻辑地址
  
第三章 汇编语言和汇编软件
  0.将汇编语言源程序转换成机器指令, 这个过程叫做编译(Compile)
  1.汇编软件NASM使用
    1.1 -f 输出文件格式
    1.2 -o 输出文件
    1.3 -O 编译优化
    1.4 -w 警告信息 
    1.5 -I Include文件目录
    1.6 -g 生成调试信息
    1.7 -l 生成List文件
    1.8 -Z 输出日志文件
    例子: nasm -wall -f bin myfile.asm -o myfile.com -l myfile.lst
  2.使用英文分号';'字母为代码添加注释

第四章 虚拟机的安装和使用
  0.8086处理器加电或复位时将代码段寄存器(CS)为0xFFFF, 其他所有寄存器都为0x0000
  1.硬盘数据的访问是以柱面(同一磁道轨迹)来组织的, 从盘面最边缘的磁道以0编号开始, 向着圆心的方向递增
  2.盘片上的磁头以0编号开始, 磁道上的扇区以1编号开始
  3.扇区与扇区之间以空白间隔开来, 每个扇区包含扇区头信息和512字节的数据区
  4.主引导扇区是硬盘的0头0柱1扇区, ROM BIOS将读取其内容加载到内存0x0000:0x7c00处, 然后用jmp指令跳到那里执行
  5.LBA模式不考虑扇区的物理位置, 而把它们全部组织成逻辑扇区统一编号
    LBA = (磁道号 * 磁头总数 + 磁头号) * 每道扇区数 + (扇区号 - 1)
  
第五章 编写主引导扇区代码
  0.有效的主引导扇区最后两字节是0x55和0xAA
  1.显卡的工作模式分文本和图形模式
  2.8086的1MB内存中, 常规内存:0x00000~0x9FFFF, ROM-BIOS内存:0xF0000~0xFFFFF, 显卡内存:0xB8000~0xBFFFF
  3.Intel的处理器不允许将一个立即数传送到段寄存器, 不允许在两个内存单元之间直接进行操作
  4.汇编地址是编译器为每条指令确定的汇编位置, 相对于段或程序内存起始处的偏移距离
  5.标号代表并指示它所在位置处指令的汇编地址
  6.数据的声明
    a. DB(Declare Byte)是声明字节
    b. DW(Declare Word)是声明字
    c. DD(Declare Double Word)是声明双字
    d. DQ(Declare Quad Word)是声明四字
  7.表达式  '被除数     ÷  除数  = 商 ··· 余数' 的(无符号)汇编映射
    a.       AX(word)     (byte)   AL      AH
    b. DX(word)+AX(word)  (word)   AX      DX
        高16位   低16位
    格式: div 除数(寄存器/内存单元)
    例子: div bl
          div word es:[0]
    技巧: 对折看, 折叠点除数
  8.指令xor操作是在两个操作数相对应的比特之间单独进行异或的(常用作清零操作)
  9.伪指令times用于重复它后面的表达式若干次
    格式: times 次数 重复表达式
  10.现代处理器加电或复位时将代码段寄存器(CS)为0xF000, 指令寄存器(IP)为0xFFF0
  11.Bochs指令
    a. 打断点(b 地址)
    b. 持续执行(c)
    c. 显示标志寄存器信息(info eflags)
    d. 自动完成循环过程(n)(cx计数循环)
    e. 查看栈信息(print-stack)
    f. 退出调试(q)
    g. 显示通用寄存器(r)
    h. 单步执行(s)
    i. 显示段寄存器(sreg)
    j. 显示物理内存地址处内容(xp /数量 地址)
    k. 反汇编操作(u /数量 [开始地址])

第六章 相同的功能, 不同的代码
  0.执行rep movsb/movsw串传送指令前, cld指令将DF标志置0(表示正向), std指令将DF标志置1(表示逆向), (cx)值决定重复传送次数
    格式: rep movsb
    功能: a. mov es:[di], byte ds:[si]
          b. if(0x00 == (DF))
               inc si
               inc di
          c. if(0x01 == (DF))
               dec si
               dec di
          d. dec cx
          e. 判断(CX)值 {=0x00 向下执行}, {!=0x00 转至a处执行}
    格式: rep movsw
    功能: a. mov es:[di], word ds:[si]
          b. if(0x00 == (DF))
               add si, 02H
               add di, 02H
          c. if(0x01 == (DF))
               sub si, 02H
               sub di, 02H
          d. dec cx
          e. 判断(CX)值 {=0x00 向下执行}, {!=0x00 转至a处执行}
  1.loop指令
    格式: loop 标号
    功能: a. (CX) = (CX) - 0x01
          b. 判断(CX)值 {=0x00 向下执行}, {!=0x00 转至loop标号处执行}
  2.neg指令功能是用0减去指令中的操作数, 结果赋值给操作数
    格式: neg 操作数(寄存器/内存单元)
  3.cbw(Convert Byte to Word)指令将寄存器al中的有符号数扩展到ax
    格式: cbw
  4.cwd(Convert Word to Double-word)指令将寄存器ax中的有符号数扩展到dx:ax
    格式: cwd
  5.idiv有符号除法指令用法与div相同, 不同是需要依据情况用cwd指令扩展ax寄存器值
  6.标志位转移指令
    a. js指令: 符号位(SF)=1转移, jns指令: 符号位(SF)=0转移
    b. jz指令: 零值位(ZF)=1转移, jnz指令: 零值位(ZF)=0转移
    c. jo指令: 溢出位(OF)=1转移, jno指令: 溢出位(OF)=0转移
    d. jc指令: 进借位(CF)=1转移, jnc指令: 进借位(CF)=0转移
    e. jp指令: 奇偶位(PF)=1转移, jnp指令: 奇偶位(PF)=0转移
    f. jpe指令: 奇偶位(PF)=1转移, jpo指令: 奇偶位(PF)=0转移
  7.nasm标记
    a. $表示当前汇编指令行的汇编地址
    b. $$表示当前汇编段的起始汇编地址
  8.Bochs中标志位符号大写(1), 小写(0)
  9.jcc指令簇中'大小'比较适用于有符号数比较, '高低'比较适用于无符号数比较
  
第七章 比高斯更快的计算
  0.采用基址寄存器bp寻址时, 默认的段寄存器是ss
  1.adc指令是带进位加法指令
    格式: adc 操作对象1, 操作对象2
    功能: (操作对象1) = (操作对象1) + (操作对象2) + (CF)
    例子: adc ax, bx
    功能: (AX) = (AX) + (BX) + (CF)
  2.sbb指令是带进位减法指令
    格式: sbb 操作对象1, 操作对象2
    功能: (操作对象1) = (操作对象1) - (操作对象2) - (CF)
    例子: sbb ax, bx
    功能: (AX) = (AX) - (BX) - (CF)
  3.push(入栈)执行步骤(栈顶从高地址向低地址方向移动)
    a. (SP) = (SP) - 0x02, ss:sp指向当前栈顶前面的单元作为新的栈顶
    b. 将内存数据送入ss:sp指向的内存单元, 此时ss:sp指向新栈顶
  4.pop(出栈)执行步骤(栈顶从低地址向高地址方向移动)
    a. 将ss:sp指向的内存单元处的数据读出(已不在栈中)
    b. (SP) = (SP) + 0x02, ss:sp指向当前栈顶后面的单元, 以当前栈顶后面的单元为新的栈顶  

第八章 硬盘和显卡的访问与控制
  0.NASM编译器使用汇编指令'SECTION'或者'SEGMENT'来定义段, 'ALIGN='来指定段的汇编地址对齐方式
     格式: [section 段名称 align=对齐方式]
  1.若整个程序都没有段的定义, 则整个程序自成一个段
  2.NASM编译器提供'section.<段名称>.start'表达式来获取某段的起始汇编地址(相对于整个程序的开头)
  3.段内标号的汇编地址计算
    a.当段定义语句中有包含'VSTART='子句时, 从它所在段的开头, 且指定的虚拟地址(vstart值)开始计算
    b.当段定义语句中不包含'VSTART='子句时, 从整个程序的开头开始计算
  4.伪指令equ声明常数
    例子: const_name equ 100
  5.指令in从端口读数据(用al或ax来存放读取或写入端口的数据)
    格式: in al/ax, dx
    例子: in al, 20H
  6.指令out向端口写数据(对256~65535端口进行读写时用dx存放端口号)
    格式: out dx, al/ax
    例子: out 20H, al/ax
  7.计算机中的PATA/SATA接口分主和副硬盘接口
    a.主硬盘接口端口号[0x01F0 ~ 0x01F7]
    b.副硬盘接口端口号[0x0170 ~ 0x0177]
  8.采用LBA28访问硬盘(最大管理128GB的硬盘)
    a.设置读写扇区数量(每成功读取一个扇区数量值减一)
        mov al, 01H         ;扇区数量(若为0值, 则表示256个扇区)
        mov dx, 01F2H       ;0x01F2端口
        out dx, al
    b.设置读写起始LBA扇区号(4字节28位有效扇区号, 依次写入0x01F3~6端口)
        mov al, 00H         ;扇区号[00 ~ 07]位
        mov dx, 01F3H       ;0x01F3端口
        out dx, al          ;
        xor al, al          ;扇区号[08 ~ 15]位
        inc dx              ;0x01F4端口
        out dx, al          ;
        xor al, al          ;扇区号[16 ~ 23]位
        inc dx              ;0x01F5端口
        out dx, al          ;
        xor al, al          ;扇区号[24 ~ 27]位
        or al, A0H          ;置高4位(B5:B7:01H)
        or al, 00H          ;设置主(B4:00H), 从(B4:10H)硬盘
        or al, 40H          ;设置CHS(B6:00H), LBA(B6:40H)模式
        inc dx              ;0x01F6端口
        out dx, al          ;
    c.设置读写数据请求
        mov al, 20H         ;读数据(20H), 写数据(30H)
        mov dx, 01F7H       ;0x01F7端口
        out dx, al
    d.循环获取读写状态
        mov dx, 01F7H       ;0x01F7端口
        sStatus:
            in al, dx
            and al, 01H     ;状态(B0:01H)有错误
            and al, 08H     ;状态(B3:08H)已准备
            and al, 80H     ;状态(B7:80H)工作中
            jmp near sStatus
    e.连续读取数据
        mov dx, 01F0H       ;0x01F0端口
        sRead:
            in ax, dx
            jmp near sRead
    f.获取错误原因
        mov dx, 01F1H       ;0x01F1端口
        in ax, dx
  9.转移指令call(将ip/cs:ip入栈, 然后转移)
    a.段内转移(= 标号处的地址 - call指令后的第一个字节的地址)(匹配ret)
      格式: call near 标号
      功能: a. push ip
            b. jmp near 标号
    b.段间转移((CS) = 标号所在段的段地址, (IP) = 标号所在段的偏移地址)(匹配retf)
      格式: call 段地址:偏移地址
      功能: a. push cs
            b. push ip
            c. jmp 段地址:偏移地址
    c.段内转移(寄存器的值, 是转移的目的偏移地址)(匹配ret)
      格式: call 寄存器(16位)
      功能: a. push ip
            b. jmp 寄存器(16位)
    d.段内转移(内存单元地址处一个字的值, 是转移的目的偏移地址)(匹配ret)
      格式: call 内存单元地址
      功能: a. push ip
            b. jmp 内存单元地址处一个字
    e.段间转移((IP) = 低地址处的一个字的值, (CS) = 高地址处的一个字的值)(匹配retf)
      格式: call far 内存单元地址
      功能: a. push cs
            b. push ip
            c. jmp far 内存单元地址处两个字        
  10.近转移指令ret(用栈中的数据修改ip)
    格式: ret
    功能: pop ip
  11.远转移指令retf(用栈中的数据修改cs和ip)
    格式: retf
    功能: a. pop ip
          b. pop cs
  12.逻辑左移指令shl
    格式: shl 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向左位移
          b. 将最后移出的一Bit位写入(CF)中
          c. 最低位用0补充
          d. 相当于执行X = X * 02H
  13.逻辑右移指令shr
    格式: shr 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向右位移
          b. 将最后移出的一Bit位写入(CF)中
          c. 最高位用0补充
          d. 相当于执行X = X / 02H
  14.循环左移指令rol
    格式: rol 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向左位移
          b. 将最后移出的一Bit位写入(CF)和右边空出的位中
  15.循环右移指令ror
    格式: ror 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向右位移
          b. 将最后移出的一Bit位写入(CF)和左边空出的位中
  16.无条件转移指令 jmp 转移指令结束后, cs:ip指向标号处的指令(编译器根据标号以补码方式计算IP的转移的位移)
    a.段内短转移(byte)
      格式: jmp short 标号
      功能: (IP) = (IP) + 8位位移(= 标号处的地址 - jmp指令后的第一个字节的地址)
    b.段内近转移(word)
      格式: jmp near 标号
      功能: (IP) = (IP) + 16位位移(= 标号处的地址 - jmp指令后的第一个字节的地址)
      格式: jmp 寄存器(16位)
      功能: (IP) = (寄存器的值, 是转移的目的偏移地址)
      格式: jmp 内存单元地址处一个字
      功能: (IP) = (内存单元地址处一个字的值, 是转移的目的偏移地址)
    c.段间转移(远转移)
      格式: jmp 段地址:偏移地址
      功能: (CS) = 段地址, (IP) = 偏移地址
      格式: jmp far 内存单元地址处两个字
      功能: (CS) = 高地址处的一个字的值, (IP) = 低地址处的一个字的值
  17.伪指令resb/w/d(REServe Byte/Word/Dword)保留指定数量的内存空间
    例子: resw 10H
  18.表达式   '因子   x   因子        =       积'   的汇编映射
    a.       (byte)     AL(byte)           AX(word)
    b.       (word)     AX(word)       DX(word)+AX(word)
                                        高16位   低16位
    格式: mul 因子(寄存器/内存单元)
    例子: mul byte es:[0]
          mul word es:[0]
  19.获取光标位置(AX)
    例子: mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0eH           ;指定0x0E光标高8位寄存器
          out dx, al            
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          in al, dx             ;读取光标高8位寄存器值
          mov ah, al
          mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0fH           ;指定0x0F光标低8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          in al, dx             ;读取光标低8位寄存器值
  20.设置光标位置(AX)
    例子: mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0eH           ;指定0x0E光标高8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          mov al, bh            ;设置光标高8位寄存器值
          out dx, al
          mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0fH           ;指定0x0F光标低8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          mov al, bl            ;设置光标低8位寄存器值
          out dx, al
    
第九章 中断和动态时钟显示
  0.从处理器外部来的中断信号是外部硬件中断
  1.不会被阻断和屏蔽的中断为非屏蔽中断NMI(Non Maskable Interrupt), 中断号统一为2
  2.可编程中断控制器(PIC)8259芯片, 有主片和从片两块各8个引脚, 从片连接在主片的2号引脚
  3.主片0号引脚接系统定时(计数)器, 从片0号引脚接外围设备控制器(ICH)(包含实时时钟芯片(RTC)和CMOS RAM)
  4.通过访问8259芯片主片端口0x20和0x21, 从片端口0xa0和0xa1可对内部中断屏蔽寄存器(IMR)控制(0表示允许, 1表示阻断中断请求信号)
  5.cli指令将(IF)标志位值置0(处理器忽略INTR引脚中断信号)
    格式: cli
    功能: (IF)=0
  6.sti指令将(IF)标志位值置1(处理器接受和响应中断信号)
    格式: sti
    功能: (IF)=1
  7.中断向量表(IVT)存放在0x0000~0x03FF物理地址, 每个中断占4个字节
  8.中断号(N)处理过程
    a.pushf
    b.(IF)=0, (TF)=0
    c.push cs
    d.push ip
    e.(IP)=(N * 04H), (CS)=(N * 04H + 02H)
    f.iret
  9.iret指令中断处理程序返回
    格式: iret
    功能: a. pop ip
          b. pop cs
          c. popf
  10.访问CMOS RAM通过索引端口0x70或0x74, 数据端口0x71或0x75
  11.处理器在执行修改段寄存器指令时, 在紧接着一条指令执行完毕之前, 禁止中断
  12.BIOS初始化时将8259芯片主片中断号设为从0x08开始, 从片中断号设为从0x70开始
  13.hlt指令使处理器停止执行指令(可被外部中断唤醒恢复继续执行)
    格式: hlt
  14.not指令按位取反
    格式: not 寄存器/内存单元
    例子: not word [bx]
  15.test指令功能上同and指令, 但是丢弃运算结果
    格式: test 寄存器/内存单元, 立即数/寄存器
    例子: test [bx], 08H
  16.内部中断由执行的指令引起发生在处理器内部, 中断类型固定且不受标志寄存器(IF)位影响不需要中断识别总线周期
  17.int指令引起软中断不需要中断识别总线周期
    格式: int N
    例子: int3 ;断点中断指令
          into ;溢出中断指令
  18.在屏幕光标处写字符, 并推进光标
    例子: mov ah, 0EH     ;功能号0x0e
          int 10H         ;(AL)写入字符
  19.从键盘获取输入字符
    例子: mov ah, 00H     ;功能号0x00
          int 16H         ;(AL)获取字符
  
  
附注
  0.详情看书吧
  
  
                                                欢迎关注 iF8s 微信公共号
                                                
                                                

