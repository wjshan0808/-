                    x86汇编语言从实模式到保护模式
                            (学习笔记一 实模式)

第一章 十六进制计数法
  0.在计算机里二进制数字对应着高(1)低(0)电平的组合
  1.一种计数法的数符个数称为基数
  2.每个数符位都有一个权值(从右向左, 以基数为底, 指数从0递增的幂)
  3.N进制数转十进制数, 依次将每一个数位值乘以其权值相加
  4.十进制数转N进制数, 反复除以N直到商为0, 将余数从近至远, 由左向右拼接, 即得N进制数
  
第二章 处理器、内存和指令
  0.高字节位于高地址, 低字节位于低地址, 称为低端字节序(Little Endian)
  1.一个处理器能够识别的指令的集合, 称为该处理器的指令集
  2.将一个16位的寄存器当成两个8位的寄存器来用时, 对其中一个8位寄存器的操作不会影响到另一个8位寄存器
  3.在指令中使用绝对内存地址的程序是无法重定位的
  4.处理器访问内存时把指令中指定的内存地址看成是段内的偏移地址(偏移地址从0x00开始), 而不是物理地址
  5.算术逻辑部件(ALU)在进行数据传送或者算术逻辑运算的时候, 需要通过一个叫数据暂存器的寄存器中转
  6.控制器使处理器自动运行, 其内部的6字节指令预取队列, 加快指令执行速度
  7.默认使用DS寄存器作为数据段地址
  8.只有处理器才能直接根据当前指令的长度来改变IP寄存器的值, 使其指向下一条指令 
  9.8086处理器提供了20根地址线, 可访问达1MB范围内存的物理地址(65536个16字节的段)
  10.8086处理器先将段寄存器值左移4位(乘以0x10), 再同偏移地址值相加, 形成20位的物理地址
  11.8086处理器的逻辑分段起始地址(偏移地址从0x00开始)都是16的倍数, 称为按16字节对齐
  12.8086内存中的一个物理地址只要位于访问段的64KB范围内, 即可对应该段的逻辑地址
  
第三章 汇编语言和汇编软件
  0.将汇编语言源程序转换成机器指令, 这个过程叫做编译(Compile)
  1.汇编软件NASM使用
    1.1 -f 输出文件格式
    1.2 -o 输出文件
    1.3 -O 编译优化
    1.4 -w 警告信息 
    1.5 -I Include文件目录
    1.6 -g 生成调试信息
    1.7 -l 生成List文件
    1.8 -Z 输出日志文件
    例子: nasm -wall -f bin myfile.asm -o myfile.com -l myfile.lst
  2.使用英文分号';'字母为代码添加注释

第四章 虚拟机的安装和使用
  0.8086处理器加电或复位时将CS寄存器设为0xFFFF, 其他所有寄存器都设为0x0000
  1.在8086处理器的系统中ROM物理地址范围是0xF0000~0xFFFFF, DRAM物理地址范围是是0x00000~0x9FFFF
  2.盘片上的磁头(盘面)以0编号开始, 磁道上的扇区以1编号开始
  3.硬盘数据的访问是以柱面(同一磁道轨迹)来组织的, 以盘面最边缘的磁道0编号开始, 向着圆心的方向递增
  4.扇区与扇区之间以空白间隔开来, 每个扇区包含扇区头信息和512字节的数据区
  5.扇区头信息包含本扇区的磁头号, 磁道号, 扇区号, 扇区健康标志及替换扇区地址
  6.主引导扇区是硬盘的0头0柱1扇区, ROM-BIOS将读取其内容加载到内存0x0000:0x7c00处, 然后用jmp指令跳到那里接着执行
  7.LBA模式不考虑扇区的物理位置, 而把它们全部组织成逻辑扇区统一编号
    LBA = (磁道号 * 磁头总数 + 磁头号) * 每道扇区数 + (扇区号 - 0x01)
  
第五章 编写主引导扇区代码
  0.ROM-BIOS读取主引导扇区的512个字节将其加载到逻辑地址0x0000:0x7c00处, 首先检测其有效性(最后两字节是0x55和0xAA), 然后用jmp指令跳到那里继续执行
  1.显卡控制显示器的最小单位是像素, 工作方式是周期性从显存读取数据, 工作模式分文本和图形模式
  2.在8086访问的1MB内存内存条提供0x00000~0x9FFFF常规内存, 芯片提供0xF0000~0xFFFFF只读BIOS内存, 外围设备提供0xA0000~0xEFFFF包括0xB8000~0xBFFFF显存
  3.Intel的处理器不允许将一个立即数传送到段寄存器, 且不允许在两个内存单元之间直接进行操作
  4.屏幕上一个字符对应显存中两个连续的字节, 低字节显示字符值, 高字节显示属性值
    属性字节    07     06     05     04           03       02      01      00
        背景:闪烁(1)  R(1)   G(1)   B(1)    前景:高亮(1)  R(1)    G(1)    B(1)
  5.访问内存单元如果没有显式指示段地址, 则默认访问DS寄存器中的值
  6.当源操作数和目的操作数都无法判断单次操作的数据宽度时, 需要明确指明操作的数据宽度
  7.mov传送指令只影响目的操作数的内容, 不改变源操作数的内容, 且操作的数据宽度相同
    格式: mov 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    例子: mov byte [0x00], 0x00
  8.汇编地址是源程序编译期间编译器为每条指令确定的汇编位置, 指示该指令相对于程序或段(偏移地址从0x00开始)处的距离, 当编译后的程序载入物理内存后也是该指令在内存段(偏移地址从0x00开始)中的偏移地址
  9.指令前的标号代表并指示该指令的汇编地址, 其值在源程序编译时确定, 且编译时将其值转换为立即数
  10.数据的声明, 多个数据之间用逗号(,)分割
    a. 伪指令DB(Declare Byte)声明字节
    b. 伪指令DW(Declare Word)声明字
    c. 伪指令DD(Declare Double word)声明双字
    d. 伪指令DQ(Declare Quad word)声明四字
  11.程序中声明的数值会被编译器在它们声明的汇编地址处原样保留
  12.表达式  '被除数    ÷  除数  = 商 ··· 余数' 的汇编映射(无符号)
    a.       AX(word)     (byte)   AL      AH
    b. DX(word)+AX(word)  (word)   AX      DX
        高16位   低16位
    格式: div 除数(通用寄存器/内存单元)
    例子: div bl
          div word es:[0x00]
    技巧: 对折看, 折叠点除数
  13.xor指令是在两个操作数相对应的比特之间单独进行异或的(常用作清零操作)
    格式: xor 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    例子: xor ax, ax
  14.add指令是将两个操作数相加, 结果保存在目的操作数中
    格式: add 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    例子: add word [0x00], 0x00
  15.jmp转移指令使处理器脱离当前执行序列, 转移到指定位置执行
    a.格式: jmp 段地址:偏移地址
      例子: jmp 0x0000:0x7c00
      解释: 段地址值传送到CS寄存器, 偏移地址值传送到IP寄存器
    b.格式: jmp near 标号
      操作数: 目标位置相对于当前指令处的偏移量(目标位置地址 - 当前指令处的汇编地址 - 当前指令的长度)
      解释: CS寄存器值不变, IP寄存器值 + 该指令操作数 + 该指令长度
  16.伪指令times重复指定次数的指定指令
    格式: times 重复的次数 重复的指令
    例子: times 0x00 db 0x00
  17.现代处理器加电或复位时将CS寄存器置为0xF000, IP寄存器置为0xFFF0
  18.Bochs指令
    a. 打断点(b 物理地址)
    b. 持续执行(c)
    c. 显示标志寄存器信息(info eflags)
    d. 自动完成循环过程(n)(cx计数循环)
    e. 查看栈信息(print-stack [/数量])
    f. 退出调试(q)
    g. 显示通用寄存器信息(r)
    h. 单步执行(s)
    i. 显示段寄存器信息(sreg)
    j. 显示物理内存地址处内容(xp /数量 物理地址)
    k. 反汇编操作(u /数量 [开始物理地址])
  19.寄存器扩展
    a.32位处理器上使用E扩展为32位数据
    b.64位处理器上使用R扩展为64位数据, 同时新增了8个64位寄存器R8~R15作为独立整体使用

第六章 相同的功能, 不同的代码
  0.若编译后的程序不是从段内偏移地址为0x00处加载的, 则程序内使用的标号地址需加上程序加载处的段内偏移地址
  1.movsb指令以字节为单位, movsw指令以字为单位, 把数据从内存中的一个地方批量复制到另一个地方
    格式: movsb/movsw
    功能: a.源数据地址: DS:SI
          b.目的数据地址: ES:DI
          c.复制方向: 正向(DF=0x00), 反向(DF=0x01)
          d.复制数量: CX值
          e.一个单位操作结束: SI/DI正向(递增)/逆向(递减)一个单位值, CX值递减一
  2.cld指令将DF标志值置0x00
    格式: cld
  3.std指令将DF标志值置0x01
    格式: std
  4.前缀rep指令重复执行后续指令, 直到CX值为0x00为止
    格式: rep 指令
    例子: rep movsb
  5.loop指令重复执行一段相同的代码
    格式: loop 标号
    操作数: 目标位置相对于当前指令处的偏移量(目标位置地址 - 当前指令处的汇编地址 - 当前指令的长度(0x02))
    解释: CS寄存器值不变, IP寄存器值 + 该指令操作数 + 该指令长度
    功能: a. (CX) = (CX) - 0x01
          b. 判断(CX)值 {=0x00 向下执行}, {!=0x00 转至loop标号处执行}
  6.在8086处理上只能用BX, BP, SI, DI寄存器来提供内存操作数的偏移地址, 但不允许BX与BP或SI与DI同时出现
  7.inc指令是将操作数的值加一
    格式: inc 寄存器/内存单元
    例子: inc word [0x00]
  8.dec指令是将操作数的值减一
    格式: dec 寄存器/内存单元
    例子: dec word [0x00]
  9.neg指令是用0x00减去指令中的操作数, 将结果赋值给操作数
    格式: neg 寄存器/内存单元
    例子: neg word [0x00]
  10.cbw(Convert Byte to Word)指令将al寄存器中的符号值扩展到整个ax寄存器
    格式: cbw
  11.cwd(Convert Word to Double-word)指令将ax寄存器中的符号值扩展到整个dx寄存器, ax寄存器值不变
    格式: cwd
  12.sub指令是将两个操作数相减, 结果保存在目的操作数中
    格式: sub 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    功能: a. neg 源操作数
          b. add 目的操作数, 源操作数
  13.表达式  '被除数    ÷  除数  = 商 ··· 余数' 的汇编映射(有符号)
    a.       AX(word)     (byte)   AL      AH
    b. DX(word)+AX(word)  (word)   AX      DX
        高16位   低16位
    格式: idiv 除数(通用寄存器/内存单元)
    例子: idiv bl
          idiv word es:[0x00]
    细节: 需要依据情况用cwd指令扩展ax寄存器中的符号值扩展到整个dx寄存器
  14.标志位
    a. PF奇偶位: 运算结果的最低8个比特位中, 有偶数个为1的比特位则PF=0x01, 否则PF=0x00
    b. CF进借位: 处理器进行算术操作时, 最高位有进位或借位发生则CF=0x01, 否则CF=0x00
    c. OF溢出位: 假定当前是两个有符号数运算, 运算结果不正确则OF=0x01, 否则OF=0x00
    d. ZF零值位: 两个操作数相同, 相减的结果为0x00则ZF=0x01, 否则ZF=0x00
  15.标志位转移指令
    格式: jcc 标号
    操作数: 目标位置相对于当前指令处的偏移量(目标位置地址 - 当前指令处的汇编地址 - 当前指令的长度)
    解释: CS寄存器值不变, IP寄存器值 + 该指令操作数 + 该指令长度
    功能: a. js 指令: 符号位(SF)=0x01转移, jns指令: 符号位(SF)=0x00转移
          b. jz 指令: 零值位(ZF)=0x01转移, jnz指令: 零值位(ZF)=0x00转移
          c. jo 指令: 溢出位(OF)=0x01转移, jno指令: 溢出位(OF)=0x00转移
          d. jc 指令: 进借位(CF)=0x01转移, jnc指令: 进借位(CF)=0x00转移
          e. jp 指令: 奇偶位(PF)=0x01转移, jnp指令: 奇偶位(PF)=0x00转移
          f. jpe指令: 奇偶位(PF)=0x01转移, jpo指令: 奇偶位(PF)=0x00转移
  16.cmp指令拿目的操作数和源操作数做大小(减法)比较, 仅根据结果设置相应标志位不保留相减结果
    格式: cmp 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    例子: cmp ax, [0x00]
  17.指令jcc簇中比较'大小'适用于有符号数相比较, 比较'高低'适用于无符号数相比较
  18.jcxz指令是当CX寄存器的值为0x00时转移
    格式: jcxz 标号
    操作数: 目标位置相对于当前指令处的偏移量(目标位置地址 - 当前指令处的汇编地址 - 当前指令的长度)
    解释: CS寄存器值不变, IP寄存器值 + 该指令操作数 + 该指令长度
  19.NASM标记
    a. $表示当前汇编指令行的汇编地址
    b. $$表示当前汇编段的起始汇编地址
  20.Bochs中标志位符号大写表示其值=0x01, 小写表示其值=0x00
  
第七章 比高斯更快的计算
  0.push指令入栈操作(栈顶从高地址向低地址方向移动)
    格式: push 寄存器/内存单元/立即数
    例子: push word [0x00]
    功能: a. (SP) = (SP) - 操作数长度, ss:sp指向当前栈顶前面的单元作为新的栈顶
          b. 将内存数据送入ss:sp指向的内存单元, 此时ss:sp指向新栈顶
  1.pop指令出栈操作(栈顶从低地址向高地址方向移动)
    格式: pop 寄存器/内存单元
    例子: pop word [0x00]
    功能: a. 将ss:sp指向的内存单元处的数据读出(已不在栈中)
          b. (SP) = (SP) + 操作数长度, ss:sp指向当前栈顶后面的单元, 以当前栈顶后面的单元为新的栈顶
  2.or指令是将两个操作数执行逻辑或运算, 结果保存在目的操作数中
    格式: or 寄存器/内存单元, 寄存器/内存单元/立即数
    例子: or byte [0x00], 0x00
  3.and指令是将两个操作数执行逻辑与运算, 结果保存在目的操作数中
    格式: and 寄存器/内存单元, 寄存器/内存单元/立即数
    例子: and byte [0x00], 0x00
  4.采用基址bp寄存器寻址时, 默认的段寄存器是ss寄存器
  5.adc指令是带进位加法指令
    格式: adc 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    功能: (目的操作数) = (目的操作数) + (源操作数) + (CF)
    例子: adc ax, bx
    解释: (AX) = (AX) + (BX) + (CF)
  6.sbb指令是带进位减法指令
    格式: sbb 通用寄存器/内存单元, 通用寄存器/内存单元/立即数
    功能: (目的操作数) = (目的操作数) - (源操作数) - (CF)
    例子: sbb ax, bx
    解释: (AX) = (AX) - (BX) - (CF)

第八章 硬盘和显卡的访问与控制
  0.NASM编译器使用汇编指令'SECTION'或者'SEGMENT'来定义段, 'ALIGN='来指定段的汇编地址对齐方式(影响下一段的起始汇编地址)
     格式: [section 段名称 align=对齐方式]
  1.若整个程序都没有段的定义, 则整个程序自成一个段
  2.NASM编译器提供'section.<段名称>.start'表达式来获取某段的起始汇编地址(相对于整个程序的开头)
  3.段内标号处的汇编地址计算
    a.当段定义语句中有包含'VSTART='子句时, 从它所在段的开头, 且指定的虚拟地址(vstart值)开始计算
    b.当段定义语句中不包含'VSTART='子句时, 从整个程序的开头开始计算
  4.伪指令equ声明常数
    例子: const_name equ 100
  5.in指令从端口读数据
    格式: in 寄存器, 寄存器/8位立即数
    例子: in al, 20H
    解释: 访问8位端口目的操作数需是AL, 访问16位端口目的操作数需是AX, 原操作数需是DX寄存器
  6.out指令向端口写数据
    格式: out 寄存器/8位立即数, 寄存器
    例子: out dx, ax
    解释: 访问8位端口原操作数需是AL, 访问16位端口原操作数需是AX, 目的操作数需是DX寄存器
  7.计算机中的PATA/SATA接口分主和副硬盘接口
    a.主硬盘接口端口号[0x01F0 ~ 0x01F7]
    b.副硬盘接口端口号[0x0170 ~ 0x0177]
  8.采用LBA28访问最大128GB的硬盘
    a.设置读写扇区数量(每成功读写一个扇区数量值减一)
        mov al, 01H         ;扇区数量(若为0值, 则表示读写256个扇区)
        mov dx, 01F2H       ;写入0x01F2端口
        out dx, al          ;
    b.设置读写起始LBA扇区号(4字节28位有效扇区号, 依次写入0x01F3~6端口)
        mov al, 00H         ;扇区号[00 ~ 07]位
        mov dx, 01F3H       ;写入0x01F3端口
        out dx, al          ;
        xor al, al          ;扇区号[08 ~ 15]位
        inc dx              ;写入0x01F4端口
        out dx, al          ;
        xor al, al          ;扇区号[16 ~ 23]位
        inc dx              ;写入0x01F5端口
        out dx, al          ;
        xor al, al          ;扇区号[24 ~ 27]位
        or al, A0H          ;置Bit位(B5,B7:01H)
        or al, 00H          ;设置主(B4:00H), 从(B4:01H)硬盘
        or al, 40H          ;设置CHS(B6:00H), LBA(B6:01H)模式
        inc dx              ;写入0x01F6端口
        out dx, al          ;
    c.设置读写数据请求
        mov al, 20H         ;读数据(20H), 写数据(30H)
        mov dx, 01F7H       ;写入0x01F7端口
        out dx, al
    d.循环获取读写状态
        mov dx, 01F7H       ;读取0x01F7端口
        sStatus:
            in al, dx
            and al, 01H     ;状态(B0:01H)有错误
            and al, 08H     ;状态(B3:01H)已准备
            and al, 80H     ;状态(B7:01H)工作中
            jmp near sStatus
    e.连续读取数据
        mov dx, 01F0H       ;读取0x01F0端口
        sRead:
            in ax, dx
            jmp near sRead
    f.获取错误原因
        mov dx, 01F1H       ;读取0x01F1端口
        in ax, dx
  9.转移指令call(将ip/cs:ip入栈, 然后转移)
    a.段内偏移量机器指令操作数(= 目标汇编地址 - 当前call指令的汇编地址 - 当前call指令的0x03字节长度)(匹配ret)
      格式: call near 目标汇编地址
      功能: a. push ip
            b. (IP) = (IP) + 段内偏移量机器指令操作数 + 当前call指令的0x03字节长度
      格式: call 寄存器/内存单元
      功能: a. push ip
            b. (IP) = 寄存器/内存单元值
    b.段间转移(匹配retf)
      格式: call 段地址:偏移地址
      功能: a. push cs
            b. push ip
            c. (CS) = 段地址值
            d. (IP) = 偏移地址值
      格式: call far 内存单元地址(偏移地址在低地址处, 段地址在高地址处)
      功能: a. push cs
            b. push ip
            c. (IP) = 低地址处的一个字的值
            d. (CS) = 高地址处的一个字的值
  10.近返回指令ret
    格式: ret
    功能: pop ip
  11.远返回指令retf
    格式: retf
    功能: a. pop ip
          b. pop cs
  12.逻辑左移指令shl
    格式: shl 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向左位移
          b. 将最后移出的一Bit位写入(CF)中
          c. 最低位用0补充
          d. 相当于执行X = X * 02H
  13.逻辑右移指令shr
    格式: shr 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向右位移
          b. 将最后移出的一Bit位写入(CF)中
          c. 最高位用0补充
          d. 相当于执行X = X / 02H
  14.循环左移指令rol
    格式: rol 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向左位移
          b. 将最后移出的一Bit位写入(CF)和右边空出的位中
  15.循环右移指令ror
    格式: ror 寄存器/内存单元, cl
    功能: a. 将寄存器或内存单元中的数据向右位移
          b. 将最后移出的一Bit位写入(CF)和左边空出的位中
  16.无条件转移指令 jmp 转移指令结束后, cs:ip指向标号处的指令(编译器根据标号以补码方式计算IP的转移的位移)
    a.段内短转移(byte)
      格式: jmp short 标号
      功能: (IP) = (IP) + 8位位移(= 标号处的地址 - jmp指令后的第一个字节的地址)
    b.段内近转移(word)
      格式: jmp near 标号
      功能: (IP) = (IP) + 16位位移(= 标号处的地址 - jmp指令后的第一个字节的地址)
      格式: jmp 寄存器(16位)
      功能: (IP) = (寄存器的值, 是转移的目的偏移地址)
      格式: jmp 内存单元地址处一个字
      功能: (IP) = (内存单元地址处一个字的值, 是转移的目的偏移地址)
    c.段间转移(远转移)
      格式: jmp 段地址:偏移地址
      功能: (CS) = 段地址, (IP) = 偏移地址
      格式: jmp far 内存单元地址处两个字
      功能: (CS) = 高地址处的一个字的值, (IP) = 低地址处的一个字的值
  17.伪指令resb/w/d(REServe Byte/Word/Dword)保留指定数量的内存空间
    例子: resw 10H
  18.表达式   '因子   x   因子        =       积'   的汇编映射
    a.       (byte)     AL(byte)           AX(word)
    b.       (word)     AX(word)       DX(word)+AX(word)
                                        高16位   低16位
    格式: mul 因子(寄存器/内存单元)
    例子: mul byte es:[0]
          mul word es:[0]
  19.获取光标位置(AX)
    例子: mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0eH           ;指定0x0E光标高8位寄存器
          out dx, al            
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          in al, dx             ;读取光标高8位寄存器值
          mov ah, al
          mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0fH           ;指定0x0F光标低8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          in al, dx             ;读取光标低8位寄存器值
  20.设置光标位置(AX)
    例子: mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0eH           ;指定0x0E光标高8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          mov al, bh            ;设置光标高8位寄存器值
          out dx, al
          mov dx, 03d4H         ;显卡索引寄存器端口号0x03D4
          mov al, 0fH           ;指定0x0F光标低8位寄存器
          out dx, al
          mov dx, 03d5H         ;显卡数据寄存器端口号0x03D5
          mov al, bl            ;设置光标低8位寄存器值
          out dx, al
    
第九章 中断和动态时钟显示
  0.从处理器外部来的中断信号是外部硬件中断
  1.不会被阻断和屏蔽的中断为非屏蔽中断NMI(Non Maskable Interrupt), 中断号统一为2
  2.可编程中断控制器(PIC)8259芯片, 有主片和从片两块各8个引脚, 从片连接在主片的2号引脚
  3.主片0号引脚接系统定时(计数)器, 从片0号引脚接外围设备控制器(ICH)(包含实时时钟芯片(RTC)和CMOS RAM)
  4.通过访问8259芯片主片端口0x20和0x21, 从片端口0xa0和0xa1可对内部中断屏蔽寄存器(IMR)控制(0表示允许, 1表示阻断中断请求信号)
  5.cli指令将(IF)标志位值置0(处理器忽略INTR引脚中断信号)
    格式: cli
    功能: (IF)=0
  6.sti指令将(IF)标志位值置1(处理器接受和响应中断信号)
    格式: sti
    功能: (IF)=1
  7.中断向量表(IVT)存放在0x0000~0x03FF物理地址, 每个中断占4个字节
  8.中断号(N)处理过程
    a.pushf
    b.(IF)=0, (TF)=0
    c.push cs
    d.push ip
    e.(IP)=(N * 04H), (CS)=(N * 04H + 02H)
    f.iret
  9.iret指令中断处理程序返回
    格式: iret
    功能: a. pop ip
          b. pop cs
          c. popf
  10.访问CMOS RAM通过索引端口0x70或0x74, 数据端口0x71或0x75
  11.处理器在执行修改段寄存器指令时, 在紧接着一条指令执行完毕之前, 禁止中断
  12.BIOS初始化时将8259芯片主片中断号设为从0x08开始, 从片中断号设为从0x70开始
  13.hlt指令使处理器停止执行指令(可被外部中断唤醒恢复继续执行)
    格式: hlt
  14.not指令按位取反
    格式: not 寄存器/内存单元
    例子: not word [bx]
  15.test指令功能上同and指令, 但是丢弃运算结果
    格式: test 寄存器/内存单元, 立即数/寄存器
    例子: test [bx], 08H
  16.内部中断由执行的指令引起发生在处理器内部, 中断类型固定且不受标志寄存器(IF)位影响不需要中断识别总线周期
  17.int指令引起软中断不需要中断识别总线周期
    格式: int N
    例子: int3 ;断点中断指令
          into ;溢出中断指令
  18.在屏幕光标处写字符, 并推进光标
    例子: mov ah, 0EH     ;功能号0x0e
          int 10H         ;(AL)写入字符
  19.从键盘获取输入字符
    例子: mov ah, 00H     ;功能号0x00
          int 16H         ;(AL)获取字符
  
  
附注
  0.详情看书吧
  
  
                                                欢迎关注 iF8s 微信公共号
                                                
                                                

